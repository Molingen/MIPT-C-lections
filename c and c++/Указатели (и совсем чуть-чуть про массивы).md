___

>`int* x;` - объявили указатель. Некий адрес в памяти, под которым лежит этот int
> Но указатель обязательно нужно инициализировать, иначе выведется какой-то мусорный адрес (чаще просто выдаст ошибку)

---

### На чем это основано?

У каждого байта в памяти есть свой адрес и с помощью `&` можно его получить:

```cpp
int i = 0;
cout << &i; // выведется адрес переменной в памяти
```

Адреса всегда хранятся в специальной переменной адреса или же "указателе":

```cpp
int i = 0;
int* ptr = &i;

float f = 0.0;
float* ptr1 = &f; 
```

В свою очередь операция разадресации `*` является унарной:
```cpp
char c = 'a';
char* ptr = &c;
*ptr = 'b';
```

В примере выше видно, как можно изменить значение переменной, не обращаясь к ней
___

==!!!== Указатели можно инкрементировать и декрементировать (можно прибавить к указателю 10  `x += 10` - "шагни на 10 размеров типов вправо от Х")
==!!!== Если x, y - это 2 указателя, то можно взять их разность. Мы получим целое число, которое говорит насколько y правее x в памяти

___
### Выделение памяти

Оно бывает:
```cpp
// Статическое 
int i;

// Динамическое
int* ptr = new int;
*ptr = 10;

// в данном случае указатель можно использовать даже
// без создания переменной
```

Учитывая, что с помощью указателей можно динамически выделять память, то это значит, что с их же помощью можно делать динамические массивы:

```cpp
int i;

int* arr = new int[i];
```

Для управления динамикой памяти есть операторы new и delete:
```cpp
long long* ptr = new long long;
int* arr = new int[10]();

delete ptr; // удалит еденичный указатель
delete[] arr; // очистит память, выделенную под массив
// если не написать [] после delete, то удалится 
// только первый элемент массива
```

___
### Передача данных по указателю

```cpp
void f(int* x) {
	*x *= 2;
}

int main() {
	int i = 5;
	f(&i); // выведется 10
	return 0;
}
```

___
==!!!== На указателях строится весь фундамент массивов
```cpp
int a[100]; // массив из 100 элементов

a[150] = 3;
a[-5] = 1; // на оба выражения выдаст варнинг, но скомпилирует

150[a]; // то же самое, что и a[150] 
```

```cpp
a[5] // это эквивалентно *(a + 5)
// массив по сути является указателем, 
// ну в каком-то смысле
```

Константные указатели встречаются очень редко, но имя массива - константный указатель, поэтому нельзя написать `ar++` , где *ar* - название массива (но можно `++ar`)

```cpp
int* const //костантный указатель на int

const int* //указатель на const int

const int* const //константный указатель на const int
```

___
