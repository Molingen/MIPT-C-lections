___

> Для функций, которым не надо ничего возвращать используется тип `void`

---
### [[Указатели (и совсем чуть-чуть про массивы)| Указатели]] на функции

Функция тоже хранится где-то в памяти, поэтому можно спросить по какому адресу она лежит

Оформляется примерно так:
```cpp
int f(double, char*) {} //имена можно не писать,
//если дальше в теле функции их не используем

int (*ptr)(double, char*) = &f;
//ptr - указатель на функцию
//вызывает сомнения, тк всё написано по старинке как в Си
```

==Для чего это надо?==
Например, чтобы передавать в функцию указатель на другую функцию

```cpp
void qsort(int* a, int count, bool (*cmp(int, int))) {
	...
}
```

Если есть указатель на функцию, то для ее вызова разыменовывать уже не надо, компилятор сам разыменует

==Что такое== `void*`==?==
Это не указатель на воид, это просто указатель на какую-то память, где непонятно что лежит, поэтому никакая арифметика для указателей не работает

___

### Функции с переменным числом аргументов

```cpp
void f(int x, ...) {}
//это будет функция которая
//принимает инт и еще много чего еще

f(1, 2, 3, 5)
```

### Функции с аргументами по умолчанию

```cpp
void f(int x, char y = 'a') {}

//эту функцию можно вызвать только с аргументом X
```

По умолчанию фиксированные аргументы всегда должны быть в конце списка аргументов f(...)

___

### Перегрузка функций (overload)

```cpp
//Пусть будет несколько функций с одинаковым названием
void f(int x);
int f(char x, int y);
double f(double z);

//будет вызвана функция, подходящая под запрос
//ошибки компиляции не последует
```

А что будет, если вызвать `f('a')`?
- компилятор смотрит есть ли функция, которая принимает в точности те типы, которые мы передали
- если ее нет, то начинаются попытки к преобразованию переданных типов (всякие действия с целочисленными типами)
- если и это не работает, то компилятор пытается преобразовать double -> int или наоборот или int -> char и т.д.
- если и это не помогло (есть какая-то неоднозначность в выборе функции) - ошибка компиляции

___
