___
> тут про операторы `new`, `delete` их перегрузки и аллокаторы
---
### Оператор placement - "new"

Оператор, который на определенный указатель (тут уже заранее выделена память) вызывает конструктор и никакую новую память не выделяет
Возвращает указатель, при этом происходит явный вызов конструктора
Требует обязательного вызова деструктора объекта

```cpp
new (pointer) TYPE (... parameters ...);
new (адрес_памяти) Тип(аргументы);

p->~T();
// явный вызов деструктора
```

---

### Перегрузка операторов new и delete

Их можно перегрузить для своих типов, а также для глобальной области

Оператор `new` выполняет два действия:
- Аллоцирует память и возвращает указатель (можно перегрузить)
- Вызывает конструктор по этому указатель (нельзя перегрузить)

```cpp
// вид глобальной перегрузки
void* operator new(size_t n) {
	...
}

// перегрузка placement-new
// так реализован базовый плейсмент
// мб логирование какое-нибудь
void* operator new(size_t n, void* p) {
	return p;
}

// вид перегрузки для класса
// статик, потому что оператор относится не к объекту,
// а к классу в общем
static void* operator new(size_t n) {
	...
}

// для массивов
static void* operator new[](size_t m) {
	...
}
```

Действие `delete` состоит из двух частей:
- Вызов деструктора по адресу (нельзя перегрузить)
- Освобождение памяти (можно перегрузить)

При перегрузке оператора `new` кастомными параметрами, нужно перегружать `delete` с такими же параметрами, поможет избежать утечек памяти

```cpp
::operator delete(...); // только освободит память
p->~T(); // только вызовет деструктор
delete p; // вызовет базовый делете
```

---

### new_handler (что делает new, когда не может выделить память)

Когда оператор **`new`** не может выделить память, он вызывает специальную функцию, называемую **`new_handler`**. Это механизм, который позволяет обрабатывать ситуации, когда память недоступна, вместо того чтобы программа завершалась с ошибкой

Работать с этим механизмом можно с помощью функций:
- `std::set_new_handler` - устанавливает пользовательский обработчик

```cpp
#include <new>


std::new_handler set_new_handler(std::new_handler new_p)
		noexcept;

// или 
void my_new_handler() {
    std::cout << "my_new_handler called\n";
    throw std::bad_alloc();
    // Если не удалось решить проблему, выбрасываем исключение
}

std::set_new_handler(my_new_handler);
```

- `std::get_new_handler` - возвращает текущий установленный обработчик `new_handler`

```cpp
#include <new>

// возвращает хендлер или nullptr
std::new_handler get_new_handler() noexcept;
```

***Что можно сделать в `new_handler`?***
- освободить память
- изменить стратегию выделения памяти
- завершить программу
- кинуть исключение

---

### Что такое аллокатор, чем аллокаторы лучше "сырых" new и delete

Аллокатор (стандартный) - шаблонный класс, у него нет полей, "обертка" над вызовами `new` и `delete`

```cpp
template <typename T>
struct std::allocator<T> {
	// n это не байты, а кол-во штук типа Т 
	T* allocate(size_t n) const {
		return static_cast<T*>(std::malloc(n * sizeof(T)));
	}

	// тот же n, что и при выделении
	void deallocate(T* ptr, size_t n) const {
		std::free(ptr);
	}

	// методы ниже необязательны, в с++23 их ваще
	// убрали в обертку над аллокаторами (вроде)
	// см ниже заголовок
	
	template <typename ... Args>
	void construct(T* p, Args&& ... args) const {
		new (p) T(std::forward<Args>(args)...);
		// Placement new
	}

	void destroy(T* p) const {
        p->~T(); // Явный вызов деструктора
    }
};
```

***Методы:***
- allocate - выделяет память для определённого количества объектов
- deallocate - освобождает ранее выделенную память
- construct - создаёт объект в выделенной памяти (обычно через placement new)
- destroy - Уничтожает объект, но не освобождает память

***Всякие прикольчики:***
1) Аллокаторы инкапсулируют логику выделения и освобождения памяти
2) Аллокаторы могут выделять память из нестандартных источников, таких как shared memory или GPU-память
3) Аллокаторы могут управлять памятью более эффективно, уменьшая фрагментацию

---

### `std::allocator_traits`

см. выше в пример кода, если не читаешь комменты

```cpp
typedef T value_type;
template <typename Alloc>
struct std::allocator_traits<Alloc> {
	static Alloc::value_type* allocate(Alloc& a, size_t n) {
		// вызов аллокатор из аллокатора,
		// это же обертка епты
		// то же самое с деаллокатором
	}
};
```